-- Smart Hadith Search - PostgreSQL Schema for Supabase
-- This schema supports hybrid search: full-text + semantic (vector) search

-- ============================================================
-- EXTENSIONS (must be enabled first in Supabase SQL Editor)
-- ============================================================
-- Run these if not already enabled:
-- CREATE EXTENSION IF NOT EXISTS vector;
-- CREATE EXTENSION IF NOT EXISTS pg_trgm;

-- ============================================================
-- CORE TABLES
-- ============================================================

-- Books: Hadith collections (Bukhari, Muslim, etc.)
CREATE TABLE IF NOT EXISTS books (
    book_id INTEGER PRIMARY KEY,
    slug TEXT UNIQUE NOT NULL,
    en_title TEXT NOT NULL,
    ar_title TEXT,
    bn_title TEXT,
    ur_title TEXT,
    description TEXT
);

-- Chapters: Subdivisions within books
CREATE TABLE IF NOT EXISTS chapters (
    chapter_id INTEGER PRIMARY KEY,
    book_id INTEGER NOT NULL REFERENCES books(book_id) ON DELETE CASCADE,
    order_index INTEGER NOT NULL,
    en_title TEXT,
    ar_title TEXT,
    bn_title TEXT,
    ur_title TEXT
);

-- Grades: Hadith authenticity classification
CREATE TABLE IF NOT EXISTS grades (
    grade_id INTEGER PRIMARY KEY,
    en_text TEXT,
    ar_text TEXT,
    bn_text TEXT,
    ur_text TEXT
);

-- Hadiths: Main content table with vector embeddings
CREATE TABLE IF NOT EXISTS hadiths (
    hadith_id INTEGER PRIMARY KEY,
    book_id INTEGER NOT NULL REFERENCES books(book_id) ON DELETE CASCADE,
    chapter_id INTEGER NOT NULL REFERENCES chapters(chapter_id) ON DELETE CASCADE,
    hadith_number INTEGER NOT NULL,
    grade_id INTEGER REFERENCES grades(grade_id) ON DELETE SET NULL,

    -- Arabic text (original, required)
    ar_text TEXT NOT NULL,
    ar_narrator TEXT,

    -- English translation
    en_text TEXT,
    en_narrator TEXT,

    -- Bengali translation
    bn_text TEXT,
    bn_narrator TEXT,

    -- Urdu translation
    ur_text TEXT,
    ur_narrator TEXT,

    -- Semantic search: 384-dimensional embedding vector
    -- Generated by paraphrase-multilingual-MiniLM-L12-v2 model
    embedding vector(384),

    -- Full-text search: auto-generated tsvector for English
    -- Weights: A (highest) for narrator, B for text
    fts_en tsvector GENERATED ALWAYS AS (
        setweight(to_tsvector('english', COALESCE(en_narrator, '')), 'A') ||
        setweight(to_tsvector('english', COALESCE(en_text, '')), 'B')
    ) STORED,

    -- Full-text search for Arabic (using 'simple' config, no stemming)
    fts_ar tsvector GENERATED ALWAYS AS (
        to_tsvector('simple', COALESCE(ar_narrator, '') || ' ' || COALESCE(ar_text, ''))
    ) STORED,

    UNIQUE(book_id, hadith_number)
);

-- ============================================================
-- INDEXES
-- ============================================================

-- Foreign key indexes (for JOIN performance)
CREATE INDEX IF NOT EXISTS idx_chapters_book ON chapters(book_id, order_index);
CREATE INDEX IF NOT EXISTS idx_hadiths_book_chapter ON hadiths(book_id, chapter_id);
CREATE INDEX IF NOT EXISTS idx_hadiths_book_number ON hadiths(book_id, hadith_number);
CREATE INDEX IF NOT EXISTS idx_hadiths_grade ON hadiths(grade_id);

-- Full-text search indexes (GIN = Generalized Inverted Index)
-- Fast for searching within tsvector columns
CREATE INDEX IF NOT EXISTS idx_hadiths_fts_en ON hadiths USING gin(fts_en);
CREATE INDEX IF NOT EXISTS idx_hadiths_fts_ar ON hadiths USING gin(fts_ar);

-- Vector similarity search index (HNSW = Hierarchical Navigable Small World)
-- Fast approximate nearest neighbor search for embeddings
-- Parameters: m=16 (connections per node), ef_construction=64 (build quality)
CREATE INDEX IF NOT EXISTS idx_hadiths_embedding ON hadiths
    USING hnsw (embedding vector_cosine_ops)
    WITH (m = 16, ef_construction = 64);

-- ============================================================
-- HYBRID SEARCH FUNCTION
-- ============================================================
-- Combines full-text and semantic search using Reciprocal Rank Fusion (RRF)

CREATE OR REPLACE FUNCTION hybrid_search(
    query_text TEXT,
    query_embedding vector(384),
    match_count INT DEFAULT 20,
    full_text_weight FLOAT DEFAULT 1.0,
    semantic_weight FLOAT DEFAULT 1.0,
    rrf_k INT DEFAULT 60,
    filter_book_id INT DEFAULT NULL
)
RETURNS TABLE(
    hadith_id INT,
    score FLOAT
)
LANGUAGE sql
STABLE
AS $$
    WITH semantic AS (
        -- Semantic search: find hadiths with similar embeddings
        SELECT
            h.hadith_id,
            ROW_NUMBER() OVER (ORDER BY h.embedding <=> query_embedding) AS rank
        FROM hadiths h
        WHERE (filter_book_id IS NULL OR h.book_id = filter_book_id)
          AND h.embedding IS NOT NULL
        ORDER BY h.embedding <=> query_embedding
        LIMIT match_count * 2
    ),
    fulltext AS (
        -- Full-text search: find hadiths matching keywords
        SELECT
            h.hadith_id,
            ROW_NUMBER() OVER (
                ORDER BY ts_rank_cd(h.fts_en, plainto_tsquery('english', query_text)) DESC
            ) AS rank
        FROM hadiths h
        WHERE h.fts_en @@ plainto_tsquery('english', query_text)
          AND (filter_book_id IS NULL OR h.book_id = filter_book_id)
        ORDER BY rank
        LIMIT match_count * 2
    )
    -- Combine using Reciprocal Rank Fusion
    -- RRF score = sum of 1/(k + rank) for each search method
    SELECT
        COALESCE(s.hadith_id, f.hadith_id) AS hadith_id,
        (
            COALESCE(semantic_weight / (rrf_k + s.rank), 0.0) +
            COALESCE(full_text_weight / (rrf_k + f.rank), 0.0)
        ) AS score
    FROM semantic s
    FULL OUTER JOIN fulltext f ON s.hadith_id = f.hadith_id
    ORDER BY score DESC
    LIMIT match_count;
$$;

-- ============================================================
-- HELPER: Semantic-only search (for when full-text has no matches)
-- ============================================================

CREATE OR REPLACE FUNCTION semantic_search(
    query_embedding vector(384),
    match_count INT DEFAULT 20,
    filter_book_id INT DEFAULT NULL
)
RETURNS TABLE(
    hadith_id INT,
    similarity FLOAT
)
LANGUAGE sql
STABLE
AS $$
    SELECT
        h.hadith_id,
        1 - (h.embedding <=> query_embedding) AS similarity
    FROM hadiths h
    WHERE (filter_book_id IS NULL OR h.book_id = filter_book_id)
      AND h.embedding IS NOT NULL
    ORDER BY h.embedding <=> query_embedding
    LIMIT match_count;
$$;
